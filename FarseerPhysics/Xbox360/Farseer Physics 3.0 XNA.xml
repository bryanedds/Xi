<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Farseer Physics 3.0 XNA</name>
    </assembly>
    <members>
        <member name="T:FarseerPhysics.Factories.JointFactory">
            <summary>
            An easy to use factory for using joints.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateRevoluteJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a revolute joint and adds it to the world
            </summary>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateRevoluteJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a revolute joint and adds it to the world
            </summary>
            <param name="world"></param>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateFixedRevoluteJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates the fixed revolute joint.
            </summary>
            <param name="world">The world.</param>
            <param name="body">The body.</param>
            <param name="bodyAnchor">The body anchor.</param>
            <param name="worldAnchor">The world anchor.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateWeldJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a weld joint
            </summary>
            <param name="world"></param>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateWeldJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a weld joint and adds it to the world
            </summary>
            <param name="world"></param>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreatePrismaticJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a prsimatic joint
            </summary>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <param name="axis"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreatePrismaticJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a prismatic joint and adds it to the world
            </summary>
            <param name="world"></param>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <param name="axis"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateLineJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a line joint
            </summary>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <param name="axis"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateLineJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a line joint and adds it to the world
            </summary>
            <param name="world"></param>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="localanchorB"></param>
            <param name="axis"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateAngleJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body)">
            <summary>
            Creates an angle joint.
            </summary>
            <param name="world">The world.</param>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.JointFactory.CreateFixedAngleJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body)">
            <summary>
            Creates a fixed angle joint.
            </summary>
            <param name="world">The world.</param>
            <param name="body">The body.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FrictionJoint">
            <summary>
            Friction joint. This is used for top-down friction.
            It provides 2D translational friction and angular friction.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.Joint.#ctor(FarseerPhysics.Dynamics.Body)">
            <summary>
            Constructor for fixed joint
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.Joint.GetReactionForce(System.Single)">
            <summary>
            Get the reaction force on body2 at the joint anchor in Newtons.
            </summary>
            <param name="inv_dt">The inv_dt.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.Joint.GetReactionTorque(System.Single)">
            <summary>
            Get the reaction torque on body2 in N*m.
            </summary>
            <param name="inv_dt">The inv_dt.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.Joint.IsFixedType">
            <summary>
            Return true if the joint is a fixed type.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.Joint.SolvePositionConstraints">
            <summary>
            Solves the position constraints.
            </summary>
            <returns>returns true if the position errors are within tolerance.</returns>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.JointType">
            <summary>
            Gets or sets the type of the joint.
            </summary>
            <value>The type of the joint.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.BodyA">
            <summary>
            Get the first body attached to this joint.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.BodyB">
            <summary>
            Get the second body attached to this joint.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.WorldAnchorA">
            <summary>
            Get the anchor point on body1 in world coordinates.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.WorldAnchorB">
            <summary>
            Get the anchor point on body2 in world coordinates.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.UserData">
            <summary>
            Set the user data pointer.
            </summary>
            <value>The data.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.Active">
            <summary>
            Short-cut function to determine if either body is inactive.
            </summary>
            <value><c>true</c> if active; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.Joint.CollideConnected">
            <summary>
            Set this flag to true if the attached bodies should collide.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FrictionJoint.MaxForce">
            <summary>
            The maximum friction force in N.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FrictionJoint.MaxTorque">
            <summary>
            The maximum friction torque in N-m.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint">
            <summary>
            A distance joint rains two points on two bodies
            to remain at a fixed distance from each other. You can view
            this as a massless, rigid rod.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.#ctor(FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            This requires defining an
            anchor point on both bodies and the non-zero length of the
            distance joint. If you don't supply a length, the local anchor points
            is used so that the initial configuration can violate the constraint
            slightly. This helps when saving and loading a game.
            @warning Do not use a zero or short length.
            </summary>
            <param name="body">The body.</param>
            <param name="bodyAnchor">The body anchor.</param>
            <param name="worldAnchor">The world anchor.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.Length">
            <summary>
            The natural length between the anchor points.
            Manipulating the length can lead to non-physical behavior when the frequency is zero.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.Frequency">
            <summary>
            The mass-spring-damper frequency in Hertz.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.DampingRatio">
            <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.LocalAnchorA">
            <summary>
            The local anchor point relative to bodyA's origin.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.LocalAnchorB">
            <summary>
            The local anchor point relative to bodyB's origin.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.BodyType">
            <summary>
            The body type.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.BodyType.Static">
            <summary>
            Zero velocity, may be manually moved. Note: even static bodies have mass.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.BodyType.Kinematic">
            <summary>
            Zero mass, non-zero velocity set by user, moved by solver
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.BodyType.Dynamic">
            <summary>
            Positive mass, non-zero velocity determined by forces, moved by solver
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.CreateFixture(FarseerPhysics.Collision.Shapes.Shape,System.Single)">
            <summary>
            Creates a fixture and attach it to this body.
            If the density is non-zero, this function automatically updates the mass of the body.
            Contacts are not created until the next time step.
            Warning: This function is locked during callbacks.
            </summary>
            <param name="shape">The shape.</param>
            <param name="density">The density.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.CreateFixture(FarseerPhysics.Collision.Shapes.Shape)">
            <summary>
            Creates a fixture with the supplied shape.
            Note: Default density is 1
            </summary>
            <param name="shape">The shape</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.DestroyFixture(FarseerPhysics.Dynamics.Fixture)">
            <summary>
            Destroy a fixture. This removes the fixture from the broad-phase and
            destroys all contacts associated with this fixture. This will
            automatically adjust the mass of the body if the body is dynamic and the
            fixture has positive density.
            All fixtures attached to a body are implicitly destroyed when the body is destroyed.
            Warning: This function is locked during callbacks.
            </summary>
            <param name="fixture">The fixture to be removed.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.SetTransform(Microsoft.Xna.Framework.Vector2@,System.Single)">
            <summary>
            Set the position of the body's origin and rotation.
            This breaks any contacts and wakes the other bodies.
            Manipulating a body's transform may cause non-physical behavior.
            </summary>
            <param name="position">The world position of the body's local origin.</param>
            <param name="rotation">The world rotation in radians.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.SetTransform(Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Set the position of the body's origin and rotation.
            This breaks any contacts and wakes the other bodies.
            Manipulating a body's transform may cause non-physical behavior.
            </summary>
            <param name="position">The world position of the body's local origin.</param>
            <param name="rotation">The world rotation in radians.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.SetTransformIgnoreContacts(Microsoft.Xna.Framework.Vector2@,System.Single)">
            <summary>
            For teleporting a body without considering new contacts immediately.
            </summary>
            <param name="position">The position.</param>
            <param name="angle">The angle.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetTransform(FarseerPhysics.Common.Transform@)">
            <summary>
            Get the body transform for the body's origin.
            </summary>
            <param name="transform">The transform of the body's origin.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Apply a force at a world point. If the force is not
            applied at the center of mass, it will generate a torque and
            affect the angular velocity. This wakes up the body.
            </summary>
            <param name="force">The world force vector, usually in Newtons (N).</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Applies a force at the center of mass.
            </summary>
            <param name="force">The force.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Applies a force at the center of mass.
            </summary>
            <param name="force">The force.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Apply a force at a world point. If the force is not
            applied at the center of mass, it will generate a torque and
            affect the angular velocity. This wakes up the body.
            </summary>
            <param name="force">The world force vector, usually in Newtons (N).</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyTorque(System.Single)">
            <summary>
            Apply a torque. This affects the angular velocity
            without affecting the linear velocity of the center of mass.
            This wakes up the body.
            </summary>
            <param name="torque">The torque about the z-axis (out of the screen), usually in N-m.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyLinearImpulse(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            It also modifies the angular velocity if the point of application
            is not at the center of mass.
            This wakes up the body.
            </summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ApplyAngularImpulse(System.Single)">
            <summary>
            Apply an angular impulse.
            </summary>
            <param name="impulse">The angular impulse in units of kg*m*m/s.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ResetMassData">
            <summary>
            This resets the mass properties to the sum of the mass properties of the fixtures.
            This normally does not need to be called unless you called SetMassData to override
            the mass and you later want to reset the mass.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetWorldPoint(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Get the world coordinates of a point given the local coordinates.
            </summary>
            <param name="localPoint">A point on the body measured relative the the body's origin.</param>
            <returns>The same point expressed in world coordinates.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetWorldPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the world coordinates of a point given the local coordinates.
            </summary>
            <param name="localPoint">A point on the body measured relative the the body's origin.</param>
            <returns>The same point expressed in world coordinates.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetWorldVector(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Get the world coordinates of a vector given the local coordinates.
            </summary>
            <param name="localVector">A vector fixed in the body.</param>
            <returns>The same vector expressed in world coordinates.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetWorldVector(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the world coordinates of a vector given the local coordinates.
            </summary>
            <param name="localVector">A vector fixed in the body.</param>
            <returns>The same vector expressed in world coordinates.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLocalPoint(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Gets a local point relative to the body's origin given a world point.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The corresponding local point relative to the body's origin.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLocalPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Gets a local point relative to the body's origin given a world point.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The corresponding local point relative to the body's origin.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLocalVector(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Gets a local vector given a world vector.
            </summary>
            <param name="worldVector">A vector in world coordinates.</param>
            <returns>The corresponding local vector.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLocalVector(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Gets a local vector given a world vector.
            </summary>
            <param name="worldVector">A vector in world coordinates.</param>
            <returns>The corresponding local vector.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromWorldPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the world linear velocity of a world point attached to this body.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromWorldPoint(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Get the world linear velocity of a world point attached to this body.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromLocalPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the world velocity of a local point.
            </summary>
            <param name="localPoint">A point in local coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromLocalPoint(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Get the world velocity of a local point.
            </summary>
            <param name="localPoint">A point in local coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Body.ShouldCollide(FarseerPhysics.Dynamics.Body)">
            <summary>
            This is used to prevent connected bodies from colliding.
            It may lie, depending on the collideConnected flag.
            </summary>
            <param name="other">The other body.</param>
            <returns></returns>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Revolutions">
            <summary>
            Gets the total number revolutions the body has made.
            </summary>
            <value>The revolutions.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.BodyType">
            <summary>
            Gets or sets the body type.
            </summary>
            <value>The type of body.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.LinearVelocity">
            <summary>
            Set the linear velocity of the center of mass.
            </summary>
            <value>The linear velocity.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.AngularVelocity">
            <summary>
            Gets or sets the angular velocity. Radians/second.
            </summary>
            <value>The angular velocity.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.LinearDamping">
            <summary>
            Gets or sets the linear damping.
            </summary>
            <value>The linear damping.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.AngularDamping">
            <summary>
            Gets or sets the angular damping.
            </summary>
            <value>The angular damping.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.IsBullet">
            <summary>
            Gets or sets a value indicating whether this body should be included in the CCD solver.
            </summary>
            <value><c>true</c> if this instance is included in CCD; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.SleepingAllowed">
            <summary>
            You can disable sleeping on this body. If you disable sleeping, the
            body will be woken.
            </summary>
            <value><c>true</c> if sleeping is allowed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Awake">
            <summary>
            Set the sleep state of the body. A sleeping body has very
            low CPU cost.
            </summary>
            <value><c>true</c> if awake; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Active">
            <summary>
            Set the active state of the body. An inactive body is not
            simulated and cannot be collided with or woken up.
            If you pass a flag of true, all fixtures will be added to the
            broad-phase.
            If you pass a flag of false, all fixtures will be removed from
            the broad-phase and all contacts will be destroyed.
            Fixtures and joints are otherwise unaffected. You may continue
            to create/destroy fixtures and joints on inactive bodies.
            Fixtures on an inactive body are implicitly inactive and will
            not participate in collisions, ray-casts, or queries.
            Joints connected to an inactive body are implicitly inactive.
            An inactive body is still owned by a b2World object and remains
            in the body list.
            </summary>
            <value><c>true</c> if active; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.FixedRotation">
            <summary>
            Set this body to have fixed rotation. This causes the mass
            to be reset.
            </summary>
            <value><c>true</c> if it has fixed rotation; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.FixtureList">
            <summary>
            Gets all the fixtures attached to this body.
            </summary>
            <value>The fixture list.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.JointList">
            <summary>
            Get the list of all joints attached to this body.
            </summary>
            <value>The joint list.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.ContactList">
            <summary>
            Get the list of all contacts attached to this body.
            Warning: this list changes during the time step and you may
            miss some collisions if you don't use ContactListener.
            </summary>
            <value>The contact list.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.UserData">
            <summary>
            Set the user data. Use this to store your application specific data.
            </summary>
            <value>The user data.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Position">
            <summary>
            Get the world body origin position.
            </summary>
            <returns>Return the world position of the body's origin.</returns>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Rotation">
            <summary>
            Get the angle in radians.
            </summary>
            <returns>Return the current world rotation angle in radians.</returns>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.IsStatic">
            <summary>
            Gets or sets a value indicating whether this body is static.
            </summary>
            <value><c>true</c> if this instance is static; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.IgnoreGravity">
            <summary>
            Gets or sets a value indicating whether this body ignores gravity.
            </summary>
            <value><c>true</c> if  it ignores gravity; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.WorldCenter">
            <summary>
            Get the world position of the center of mass.
            </summary>
            <value>The world position.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.LocalCenter">
            <summary>
            Get the local position of the center of mass.
            </summary>
            <value>The local position.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Mass">
            <summary>
            Gets or sets the mass. Usually in kilograms (kg).
            </summary>
            <value>The mass.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Body.Inertia">
            <summary>
            Get or set the rotational inertia of the body about the local origin. usually in kg-m^2.
            </summary>
            <value>The inertia.</value>
        </member>
        <member name="T:FarseerPhysics.Common.Path">
            <summary>
            Path:
            Very similar to Vertices, but this
            class contains vectors describing
            control points on a Catmull-Rom
            curve.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Path.ControlPoints">
            <summary>
            All the points that makes up the curve
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Path.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path"/> class.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Path.#ctor(Microsoft.Xna.Framework.Vector2[])">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path"/> class.
            </summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.#ctor(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector2})">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path"/> class.
            </summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.NextIndex(System.Int32)">
            <summary>
            Gets the next index of a controlpoint
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Path.PreviousIndex(System.Int32)">
            <summary>
            Gets the previous index of a controlpoint
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Path.Translate(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Translates the control points by the specified vector.
            </summary>
            <param name="vector">The vector.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.Scale(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Scales the control points by the specified vector.
            </summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.Rotate(System.Single)">
            <summary>
            Rotate the control points by the defined value in radians.
            </summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.GetVertices(System.Int32)">
            <summary>
            Returns a set of points defining the
            curve with the specifed number of divisions
            between each control point.
            </summary>
            <param name="divisions">Number of divisions between each control point.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Path.GetPositionNormal(System.Single)">
            <summary>
            Gets the normal for the given time.
            </summary>
            <param name="time">The time</param>
            <returns>The normal.</returns>
        </member>
        <member name="P:FarseerPhysics.Common.Path.Closed">
            <summary>
            True if the curve is closed.
            </summary>
            <value><c>true</c> if closed; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices)">
             <summary>
             Decomposes a non-convex polygon into a number of convex polygons, up
             to maxPolys (remaining pieces are thrown out).
            
             Each resulting polygon will have no more than Settings.MaxPolygonVertices
             vertices.
             
             Warning: Only works on simple polygons
             </summary>
             <param name="vertices">The vertices.</param>
             <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices,System.Int32,System.Single)">
             <summary>
             Decomposes a non-convex polygon into a number of convex polygons, up
             to maxPolys (remaining pieces are thrown out).
            
             Each resulting polygon will have no more than Settings.MaxPolygonVertices
             vertices.
             
             Warning: Only works on simple polygons
             </summary>
             <param name="vertices">The vertices.</param>
             <param name="maxPolys">The maximum number of polygons.</param>
             <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.PolygonizeTriangles(System.Collections.Generic.List{FarseerPhysics.Common.Decomposition.Triangle},System.Int32,System.Single)">
             <summary>
             Turns a list of triangles into a list of convex polygons. Very simple
             method - start with a seed triangle, keep adding triangles to it until
             you can't add any more without making the polygon non-convex.
            
             Returns an integer telling how many polygons were created.  Will fill
             polys array up to polysLength entries, which may be smaller or larger
             than the return value.
             
             Takes O(N///P) where P is the number of resultant polygons, N is triangle
             count.
             
             The final polygon list will not necessarily be minimal, though in
             practice it works fairly well.
             </summary>
             <param name="triangulated">The triangulated.</param>
            <param name="maxPolys"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(FarseerPhysics.Common.Vertices)">
             <summary>
             Triangulates a polygon using simple ear-clipping algorithm. Returns
             size of Triangle array unless the polygon can't be triangulated.
             This should only happen if the polygon self-intersects,
             though it will not _always_ return null for a bad polygon - it is the
             caller's responsibility to check for self-intersection, and if it
             doesn't, it should at least check that the return value is non-null
             before using. You're warned!
            
             Triangles may be degenerate, especially if you have identical points
             in the input to the algorithm.  Check this before you use them.
            
             This is totally unoptimized, so for large polygons it should not be part
             of the simulation loop.
            
             Warning: Only works on simple polygons.
             </summary>
             <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.ResolvePinchPoint(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@)">
            <summary>
            Finds and fixes "pinch points," points where two polygon
            vertices are at the same point.
            If a pinch point is found, pin is broken up into poutA and poutB
            and true is returned; otherwise, returns false.
            Mostly for internal use.
            </summary>
            <param name="pin">The pin.</param>
            <param name="poutA">The pout A.</param>
            <param name="poutB">The pout B.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(System.Int32,System.Int32)">
            <summary>
            Fix for obnoxious behavior for the % operator for negative numbers...
            </summary>
            <param name="x">The x.</param>
            <param name="modulus">The modulus.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.IsEar(System.Int32,System.Single[],System.Single[],System.Int32)">
             <summary>
             Checks if vertex i is the tip of an ear in polygon defined by xv[] and
             yv[].
            
             Assumes clockwise orientation of polygon...ick
             </summary>
             <param name="i">The i.</param>
             <param name="xv">The xv.</param>
             <param name="yv">The yv.</param>
             <param name="xvLength">Length of the xv.</param>
             <returns>
             	<c>true</c> if the specified i is ear; otherwise, <c>false</c>.
             </returns>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.EdgeShape">
            <summary>
            A line segment (edge) Shape. These can be connected in chains or loops
            to other edge Shapes. The connectivity information is used to ensure
            correct contact normals.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.Shape">
            <summary>
            A shape is used for collision detection. You can create a shape however you like.
            Shapes used for simulation in World are created automatically when a Fixture
            is created. Shapes may encapsulate a one or more child shapes.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.Shape.Radius">
            <summary>
            Radius of the Shape
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.Clone">
            <summary>
            Clone the concrete shape
            </summary>
            <returns>A clone of the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.TestPoint(FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">a point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.ComputeMass(FarseerPhysics.Collision.Shapes.MassData@,System.Single)">
            <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
            <param name="massData">Returns the mass data for this shape.</param>
            <param name="density">The density in kilograms per meter squared.</param>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.Shape.ShapeType">
            <summary>
            Get the type of this shape. You can use this to down cast to the concrete shape.
            </summary>
            <value>The type of the shape.</value>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.Shape.ChildCount">
            <summary>
            Get the number of child primitives.
            </summary>
            <value></value>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex0">
            <summary>
            Optional adjacent vertices. These are used for smooth collision.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex1">
            <summary>
            These are the edge vertices
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex2">
            <summary>
            These are the edge vertices
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex3">
            <summary>
            Optional adjacent vertices. These are used for smooth collision.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.Set(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Set this as an isolated edge.
            </summary>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.TestPoint(FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">a point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
            Implement Shape.
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.ComputeMass(FarseerPhysics.Collision.Shapes.MassData@,System.Single)">
            <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
            <param name="massData">Returns the mass data for this shape.</param>
            <param name="density">The density in kilograms per meter squared.</param>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FixedLineJoint">
            <summary>
            A line joint. This joint provides two degrees of freedom: translation
            along an axis fixed in body1 and rotation in the plane. You can use a
            joint limit to restrict the range of motion and a joint motor to drive
            the motion or to model joint friction.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.FixedLineJoint.#ctor(FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Initialize the bodies, anchors, axis, and reference angle using the local
            anchor and world axis.
            This requires defining a line of
            motion using an axis and an anchor point. Uses local
            anchor points and a local axis so that the initial configuration
            can violate the constraint slightly. The joint translation is zero
            when the local anchor points coincide in world space. Using local
            anchors and a local axis helps when saving and loading a game.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="anchor">The anchor.</param>
            <param name="axis">The axis.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedLineJoint.EnableLimit">
            <summary>
            Enable/disable the joint limit.
            </summary>
            <value><c>true</c> if [enable limit]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedLineJoint.LowerLimit">
            <summary>
            The lower translation limit, usually in meters.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedLineJoint.UpperLimit">
            <summary>
            The upper translation limit, usually in meters.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedLineJoint.MotorEnabled">
            <summary>
            Enable/disable the joint motor.
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedLineJoint.MotorSpeed">
            <summary>
            The desired motor speed in radians per second.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedLineJoint.MaxMotorForce">
            <summary>
            The maximum motor torque, usually in N-m.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedLineJoint.MotorForce">
            <summary>
            Get the current motor force, usually in N.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedLineJoint.LocalAnchorA">
            <summary>
            The local anchor point relative to body1's origin.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedLineJoint.LocalAnchorB">
            <summary>
            The local anchor point relative to body2's origin.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedLineJoint.JointTranslation">
            <summary>
            Get the current joint translation, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedLineJoint.JointSpeed">
            <summary>
            Get the current joint translation speed, usually in meters per second.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.AngleJoint">
            <summary>
            Maintains a fixed angle between two bodies
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.RevoluteJoint">
            <summary>
            A revolute joint rains to bodies to share a common point while they
            are free to rotate about the point. The relative rotation about the shared
            point is the joint angle. You can limit the relative rotation with
            a joint limit that specifies a lower and upper angle. You can use a motor
            to drive the relative rotation about the shared point. A maximum motor torque
            is provided so that infinite forces are not generated.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.RevoluteJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Initialize the bodies and local anchor.
            This requires defining an
            anchor point where the bodies are joined. The definition
            uses local anchor points so that the initial configuration
            can violate the constraint slightly. You also need to
            specify the initial relative angle for joint limits. This
            helps when saving and loading a game.
            The local anchor points are measured from the body's origin
            rather than the center of mass because:
            1. you might not know where the center of mass will be.
            2. if you add/remove shapes from a body and recompute the mass,
            the joints will be broken.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second anchor.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.JointAngle">
            <summary>
            Get the current joint angle in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.JointSpeed">
            <summary>
            Get the current joint angle speed in radians per second.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.LimitEnabled">
            <summary>
            Is the joint limit enabled?
            </summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.LowerLimit">
            <summary>
            Get the lower joint limit in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.UpperLimit">
            <summary>
            Get the upper joint limit in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MotorEnabled">
            <summary>
            Is the joint motor enabled?
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MotorSpeed">
            <summary>
            Set the motor speed in radians per second.
            </summary>
            <value>The speed.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MaxMotorTorque">
            <summary>
            Set the maximum motor torque, usually in N-m.
            </summary>
            <value>The torque.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MotorTorque">
            <summary>
            Get the current motor torque, usually in N-m.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.GearJoint">
            <summary>
            A gear joint is used to connect two joints together. Either joint
            can be a revolute or prismatic joint. You specify a gear ratio
            to bind the motions together:
            coordinate1 + ratio * coordinate2 = ant
            The ratio can be negative or positive. If one joint is a revolute joint
            and the other joint is a prismatic joint, then the ratio will have units
            of length or units of 1/length.
            @warning The revolute and prismatic joints must be attached to
            fixed bodies (which must be body1 on those joints).
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.GearJoint.#ctor(FarseerPhysics.Dynamics.Joints.Joint,FarseerPhysics.Dynamics.Joints.Joint,System.Single)">
            <summary>
            Requires two existing revolute or prismatic joints (any combination will work).
            The provided joints must attach a dynamic body to a static body.
            </summary>
            <param name="jointA">The first joint.</param>
            <param name="jointB">The second joint.</param>
            <param name="ratio">The ratio.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.GearJoint.Ratio">
            <summary>
            The gear ratio.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.GearJoint.JointA">
            <summary>
            The first revolute/prismatic joint attached to the gear joint.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.GearJoint.JointB">
            <summary>
            The second revolute/prismatic joint attached to the gear joint.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Contacts.ContactEdge">
            <summary>
            A contact edge is used to connect bodies and contacts together
            in a contact graph where each body is a node and each contact
            is an edge. A contact edge belongs to a doubly linked list
            maintained in each attached body. Each contact has two contact
            nodes, one for each attached body.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Contact">
            <summary>
            The contact
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Next">
            <summary>
            The next contact edge in the body's contact list
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Other">
            <summary>
            Provides quick access to the other body attached.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Prev">
            <summary>
            The previous contact edge in the body's contact list
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Island">
            <summary>
            Used when crawling contact graph when forming islands.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching">
            <summary>
            Set when the shapes are touching.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled">
            <summary>
            This contact can be disabled (by user)
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Filter">
            <summary>
            This contact needs filtering because a fixture filter was changed.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.BulletHit">
            <summary>
            This bullet contact had a TOI event
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Contacts.Contact">
            <summary>
            The class manages contact between two shapes. A contact exists for each overlapping
            AABB in the broad-phase (except if filtered). Therefore a contact object may exist
            that has no contact points.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.GetManifold(FarseerPhysics.Collision.Manifold@)">
            <summary>
            Get the contact manifold. Do not modify the manifold unless you understand the
            internals of Box2D.
            </summary>
            <param name="manifold">The manifold.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.GetWorldManifold(FarseerPhysics.Collision.WorldManifold@)">
            <summary>
            Gets the world manifold.
            </summary>
            <param name="worldManifold">The world manifold.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.IsTouching">
            <summary>
            Determines whether this contact is touching.
            </summary>
            <returns>
            	<c>true</c> if this instance is touching; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.FlagForFiltering">
            <summary>
            Flag this contact for filtering. Filtering will occur the next time step.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.Update(FarseerPhysics.Dynamics.ContactManager)">
            <summary>
            Update the contact manifold and touching status.
            Note: do not assume the fixture AABBs are overlapping or are valid.
            </summary>
            <param name="contactManager">The contact manager.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.Evaluate(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Common.Transform@,FarseerPhysics.Common.Transform@)">
            <summary>
            Evaluate this contact with your own manifold and transforms.   
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="transformA">The first transform.</param>
            <param name="transformB">The second transform.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Contacts.Contact.Enabled">
            Enable/disable this contact. This can be used inside the pre-solve
            contact listener. The contact is only disabled for the current
            time step (or sub-step in continuous collisions).
        </member>
        <member name="P:FarseerPhysics.Dynamics.Contacts.Contact.ChildIndexA">
            <summary>
            Get the child primitive index for fixture A.
            </summary>
            <value>The child index A.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Contacts.Contact.ChildIndexB">
            <summary>
            Get the child primitive index for fixture B.
            </summary>
            <value>The child index B.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Contacts.Contact.Next">
            <summary>
            Get the next contact in the world's contact list.
            </summary>
            <value>The next.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Contacts.Contact.Prev">
            <summary>
            Get the previous contact in the world's contact list.
            </summary>
            <value>The prev.</value>
        </member>
        <member name="T:FarseerPhysics.Collision.TOIInput">
            <summary>
            Input parameters for CalculateTimeOfImpact
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.TimeOfImpact.CalculateTimeOfImpact(FarseerPhysics.Collision.TOIOutput@,FarseerPhysics.Collision.TOIInput@)">
            <summary>
            Compute the upper bound on time before two shapes penetrate. Time is represented as
            a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
            non-tunneling collision. If you change the time interval, you should call this function
            again.
            Note: use Distance() to compute the contact point and normal at the time of impact.
            </summary>
            <param name="output">The output.</param>
            <param name="input">The input.</param>
        </member>
        <member name="T:FarseerPhysics.Collision.ContactFeature">
            <summary>
            The features that intersect to form the contact point
            This must be 4 bytes or less.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.IndexA">
            <summary>
            Feature index on ShapeA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.IndexB">
            <summary>
            Feature index on ShapeB
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.TypeA">
            <summary>
            The feature type on ShapeA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.TypeB">
            <summary>
            The feature type on ShapeB
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.ContactID">
            <summary>
            Contact ids to facilitate warm starting.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactID.Features">
            <summary>
            The features that intersect to form the contact point
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactID.Key">
            <summary>
            Used to quickly compare contact ids.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.ManifoldPoint">
            <summary>
            A manifold point is a contact point belonging to a contact
            manifold. It holds details related to the geometry and dynamics
            of the contact points.
            The local point usage depends on the manifold type:
            -ShapeType.Circles: the local center of circleB
            -SeparationFunction.FaceA: the local center of cirlceB or the clip point of polygonB
            -SeparationFunction.FaceB: the clip point of polygonA
            This structure is stored across time steps, so we keep it small.
            Note: the impulses are used for internal caching and may not
            provide reliable contact forces, especially for high speed collisions.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ManifoldPoint.Id">
            <summary>
            Uniquely identifies a contact point between two Shapes
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Manifold">
            <summary>
            A manifold for two touching convex Shapes.
            Box2D supports multiple types of contact:
            - clip point versus plane with radius
            - point versus point with radius (circles)
            The local point usage depends on the manifold type:
            -ShapeType.Circles: the local center of circleA
            -SeparationFunction.FaceA: the center of faceA
            -SeparationFunction.FaceB: the center of faceB
            Similarly the local normal usage:
            -ShapeType.Circles: not used
            -SeparationFunction.FaceA: the normal on polygonA
            -SeparationFunction.FaceB: the normal on polygonB
            We store contacts in this way so that position correction can
            account for movement, which is critical for continuous physics.
            All contact scenarios must be expressed in one of these types.
            This structure is stored across time steps, so we keep it small.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.LocalNormal">
            <summary>
            Not use for Type.SeparationFunction.Points
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.LocalPoint">
            <summary>
            Usage depends on manifold type
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.PointCount">
            <summary>
            The number of manifold points
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.Points">
            <summary>
            The points of contact
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.WorldManifold">
            <summary>
            This is used to compute the current state of a contact manifold.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.WorldManifold.Normal">
            <summary>
            world vector pointing from A to B
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.WorldManifold.Points">
            <summary>
            world contact point (point of intersection)
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.WorldManifold.#ctor(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Common.Transform@,System.Single,FarseerPhysics.Common.Transform@,System.Single)">
            <summary>
            Evaluate the manifold with supplied transforms. This assumes
            modest motion from the original state. This does not change the
            point count, impulses, etc. The radii must come from the Shapes
            that generated the manifold.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="transformA">The transform for A.</param>
            <param name="radiusA">The radius for A.</param>
            <param name="transformB">The transform for B.</param>
            <param name="radiusB">The radius for B.</param>
        </member>
        <member name="T:FarseerPhysics.Collision.PointState">
            <summary>
            This is used for determining the state of contact points.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Null">
            <summary>
            Point does not exist
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Add">
            <summary>
            Point was added in the update
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Persist">
            <summary>
            Point persisted across the update
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Remove">
            <summary>
            Point was removed in the update
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.ClipVertex">
            <summary>
            Used for computing contact manifolds.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.RayCastInput">
            <summary>
            Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.RayCastOutput">
            <summary>
            Ray-cast output data.  The ray hits at p1 + fraction * (p2 - p1), where p1 and p2
            come from RayCastInput. 
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.AABB">
            <summary>
            An axis aligned bounding box.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.AABB.LowerBound">
            <summary>
            The lower vertex
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.AABB.UpperBound">
            <summary>
            The upper vertex
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.IsValid">
            <summary>
            Verify that the bounds are sorted.
            </summary>
            <returns>
            	<c>true</c> if this instance is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Combine(FarseerPhysics.Collision.AABB@)">
            <summary>
            Combine an AABB into this one.
            </summary>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Combine(FarseerPhysics.Collision.AABB@,FarseerPhysics.Collision.AABB@)">
            <summary>
            Combine two AABBs into this one.
            </summary>
            <param name="aabb1">The aabb1.</param>
            <param name="aabb2">The aabb2.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Contains(FarseerPhysics.Collision.AABB@)">
            <summary>
            Does this aabb contain the provided AABB.
            </summary>
            <param name="aabb">The aabb.</param>
            <returns>
            	<c>true</c> if it contains the specified aabb; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Contains(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Determines whether the AAABB contains the specified point.
            </summary>
            <param name="point">The point.</param>
            <returns>
            	<c>true</c> if it contains the specified point; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Center">
            <summary>
            Get the center of the AABB.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Extents">
            <summary>
            Get the extents of the AABB (half-widths).
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Perimeter">
            <summary>
            Get the perimeter length
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Vertices">
            <summary>
            Gets the vertices of the AABB.
            </summary>
            <value>The corners of the AABB</value>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollideCircles(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)">
            Compute the collision manifold between two circles.
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollidePolygonAndCircle(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Compute the collision manifold between a polygon and a circle.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="polygonA">The polygon A.</param>
            <param name="transformA">The transform of A.</param>
            <param name="circleB">The circle B.</param>
            <param name="transformB">The transform of B.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollidePolygons(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Compute the collision manifold between two polygons.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="polyA">The poly A.</param>
            <param name="transformA">The transform A.</param>
            <param name="polyB">The poly B.</param>
            <param name="transformB">The transform B.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FarseerPhysics.Collision.Collision.CollideEdgeAndCircle(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.EdgeShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)" -->
        <member name="M:FarseerPhysics.Collision.Collision.CollideEdgeAndPolygon(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.EdgeShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
             <summary>
             Collide and edge and polygon. This uses the SAT and clipping to produce up to 2 contact points.
             Edge adjacency is handle to produce locally valid contact points and normals. This is intended
             to allow the polygon to slide smoothly over an edge chain.
            
             Algorithm
             1. Classify front-side or back-side collision with edge.
             2. Compute separation
             3. Process adjacent edges
             4. Classify adjacent edge as convex, flat, null, or concave
             5. Skip null or concave edges. Concave edges get a separate manifold.
             6. If the edge is flat, compute contact points as normal. Discard boundary points.
             7. If the edge is convex, compute it's separation.
             8. Use the minimum separation of up to three edges. If the minimum separation
                is not the primary edge, return.
             9. If the minimum separation is the primary edge, compute the contact points and return.
             </summary>
             <param name="manifold">The manifold.</param>
             <param name="edgeA">The edge A.</param>
             <param name="xfA">The xf A.</param>
             <param name="polygonB_in">The polygon b_in.</param>
             <param name="xfB">The xf B.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.ClipSegmentToLine(FarseerPhysics.Common.FixedArray2{FarseerPhysics.Collision.ClipVertex}@,FarseerPhysics.Common.FixedArray2{FarseerPhysics.Collision.ClipVertex}@,Microsoft.Xna.Framework.Vector2,System.Single,System.Int32)">
            <summary>
            Clipping for contact manifolds.
            </summary>
            <param name="vOut">The v out.</param>
            <param name="vIn">The v in.</param>
            <param name="normal">The normal.</param>
            <param name="offset">The offset.</param>
            <param name="vertexIndexA">The vertex index A.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.EdgeSeparation(FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,System.Int32,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Find the separation between poly1 and poly2 for a give edge normal on poly1.
            </summary>
            <param name="poly1">The poly1.</param>
            <param name="xf1">The XF1.</param>
            <param name="edge1">The edge1.</param>
            <param name="poly2">The poly2.</param>
            <param name="xf2">The XF2.</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FarseerPhysics.Collision.Collision.FindMaxSeparation(System.Int32@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)" -->
        <member name="M:FarseerPhysics.Common.PolygonManipulation.BooleanTools.Union(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.PolygonManipulation.PolyUnionError@)">
            <summary>
            Merges two polygons, given that they intersect.
            </summary>
            <param name="polygon1">The first polygon.</param>
            <param name="polygon2">The second polygon.</param>
            <param name="error">The error returned from union</param>
            <returns>The union of the two polygons, or null if there was an error.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.BooleanTools.Subtract(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.PolygonManipulation.PolyUnionError@)">
            <summary>
            Subtracts one polygon from another.
            </summary>
            <param name="polygon1">The base polygon.</param>
            <param name="polygon2">The polygon to subtract from the base.</param>
            <param name="error">The error.</param>
            <returns>
            The result of the polygon subtraction, or null if there was an error.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.BooleanTools.Intersect(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.PolygonManipulation.PolyUnionError@)">
            <summary>
            Finds the intersection between two polygons.
            </summary>
            <param name="polygon1">The first polygon.</param>
            <param name="polygon2">The second polygon.</param>
            <param name="error">The error.</param>
            <returns>
            The intersection of the two polygons, or null if there was an error.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.BooleanTools.PreparePolygons(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@,System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.EdgeIntersectInfo}@,FarseerPhysics.Common.PolygonManipulation.PolyUnionError@)">
            <summary>
            Prepares the polygons.
            </summary>
            <param name="polygon1">The polygon1.</param>
            <param name="polygon2">The polygon2.</param>
            <param name="poly1">The poly1.</param>
            <param name="poly2">The poly2.</param>
            <param name="intersections">The intersections.</param>
            <param name="error">The error.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.BooleanTools.VerticesIntersect(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.EdgeIntersectInfo}@)">
            <summary>
            Check and return polygon intersections
            </summary>
            <param name="polygon1"></param>
            <param name="polygon2"></param>
            <param name="intersections"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.BooleanTools.PointInPolygonAngle(Microsoft.Xna.Framework.Vector2,FarseerPhysics.Common.Vertices)">
            <summary>
            * ref: http://ozviz.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/  - Solution 2 
            * Compute the sum of the angles made between the test point and each pair of points making up the polygon. 
            * If this sum is 2pi then the point is an interior point, if 0 then the point is an exterior point. 
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.BooleanTools.VectorAngle(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Return the angle between two vectors on a plane
            The angle is from vector 1 to vector 2, positive anticlockwise
            The result is between -pi -> pi
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.BooleanTools.Round(FarseerPhysics.Common.Vertices)">
            <summary>
            Rounds vertices X and Y values to whole numbers.
            </summary>
            <param name="polygon">The polygon whose vertices should be rounded.</param>
            <returns>A new polygon with rounded vertices.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.PolygonManipulation.PolyUnionError">
            <summary>
            Enumerator to specify errors with Polygon functions.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.PulleyJoint">
            <summary>
            The pulley joint is connected to two bodies and two fixed ground points.
            The pulley supports a ratio such that:
            length1 + ratio * length2 <!--<-->= ant
            Yes, the force transmitted is scaled by the ratio.
            The pulley also enforces a maximum length limit on both sides. This is
            useful to prevent one side of the pulley hitting the top.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.PulleyJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.
            This requires two ground anchors,
            two dynamic body anchor points, max lengths for each side,
            and a pulley ratio.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="groundAnchorA">The ground anchor for the first body.</param>
            <param name="groundAnchorB">The ground anchor for the second body.</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second body anchor.</param>
            <param name="ratio">The ratio.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PulleyJoint.GroundAnchorA">
            <summary>
            Get the first ground anchor.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PulleyJoint.GroundAnchorB">
            <summary>
            Get the second ground anchor.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PulleyJoint.LengthA">
            <summary>
            Get the current length of the segment attached to body1.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PulleyJoint.LengthB">
            <summary>
            Get the current length of the segment attached to body2.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PulleyJoint.Ratio">
            <summary>
            Get the pulley ratio.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.PrismaticJoint">
            <summary>
            A prismatic joint. This joint provides one degree of freedom: translation
            along an axis fixed in body1. Relative rotation is prevented. You can
            use a joint limit to restrict the range of motion and a joint motor to
            drive the motion or to model joint friction.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.PrismaticJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            This requires defining a line of
            motion using an axis and an anchor point. The definition uses local
            anchor points and a local axis so that the initial configuration
            can violate the constraint slightly. The joint translation is zero
            when the local anchor points coincide in world space. Using local
            anchors and a local axis helps when saving and loading a game.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second body anchor.</param>
            <param name="axis">The axis.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.JointTranslation">
            <summary>
            Get the current joint translation, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.JointSpeed">
            <summary>
            Get the current joint translation speed, usually in meters per second.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.LimitEnabled">
            <summary>
            Is the joint limit enabled?
            </summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.LowerLimit">
            <summary>
            Get the lower joint limit, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.UpperLimit">
            <summary>
            Get the upper joint limit, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MotorEnabled">
            <summary>
            Is the joint motor enabled?
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MotorSpeed">
            <summary>
            Set the motor speed, usually in meters per second.
            </summary>
            <value>The speed.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MaxMotorForce">
            <summary>
            Set the maximum motor force, usually in N.
            </summary>
            <value>The force.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MotorForce">
            <summary>
            Get the current motor force, usually in N.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.BayazitDecomposer">
            <summary>
            Convex decomposition algorithm created by Mark Bayazit (http://mnbayazit.com/)
            For more information about this algorithm, see http://mnbayazit.com/406/bayazit
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices)">
            <summary>
            Precondition: Counter Clockwise polygon
            Decompose the polygon into several smaller non-concave polygon.
            If the polygon is already convex, it will return the original polygon, unless it is over Settings.MaxPolygonVertices.
            </summary>
            <param name="vertices"></param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FixedMouseJoint">
            <summary>
            A mouse joint is used to make a point on a body track a
            specified world point. This a soft constraint with a maximum
            force. This allows the constraint to stretch and without
            applying huge forces.
            NOTE: this joint is not documented in the manual because it was
            developed to be used in the testbed. If you want to learn how to
            use the mouse joint, look at the testbed.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.#ctor(FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2)">
            <summary>
            This requires a world target point,
            tuning parameters, and the time step.
            </summary>
            <param name="body">The body.</param>
            <param name="target">The target.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.Target">
            <summary>
            The initial world target point. This is assumed
            to coincide with the body anchor initially.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.MaxForce">
            <summary>
            The maximum constraint force that can be exerted
            to move the candidate body. Usually you will express
            as some multiple of the weight (multiplier * mass * gravity).
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.Frequency">
            <summary>
            The response speed.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.DampingRatio">
            <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Removes all collinear points on the polygon.
            </summary>
            <param name="vertices">The polygon that needs simplification.</param>
            <param name="collinearityTolerance">The collinearity tolerance.</param>
            <returns>A simplified polygon.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(FarseerPhysics.Common.Vertices)">
            <summary>
            Removes all collinear points on the polygon.
            Has a default bias of 0
            </summary>
            <param name="vertices">The polygon that needs simplification.</param>
            <returns>A simplified polygon.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DouglasPeuckerSimplify(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Ramer-Douglas-Peucker polygon simplification algorithm. This is the general recursive version that does not use the
            speed-up technique by using the Melkman convex hull.
            
            If you pass in 0, it will remove all collinear points
            </summary>
            <returns>The simplified polygon</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.MergeParallelEdges(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Merges all parallel edges in the list of vertices
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="tolerance">The tolerance.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.ReduceByDistance(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Reduces the polygon by distance.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="distance">The distance between points. Points closer than this will be 'joined'.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.ReduceByNth(FarseerPhysics.Common.Vertices,System.Int32)">
            <summary>
            Reduces the polygon by removing the Nth vertex in the vertices list.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="nth">The Nth point to remove. Example: 5.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.ConvexHull.GiftWrap.GetConvexHull(FarseerPhysics.Common.Vertices)">
            <summary>
            Find the convex hull of a point cloud using "Gift-wrap" algorithm - start
            with an extremal point, and walk around the outside edge by testing
            angles.
            
            Runs in O(N*S) time where S is number of sides of resulting polygon.
            Worst case: point cloud is all vertices of convex polygon -&gt; O(N^2).
            There may be faster algorithms to do this, should you need one -
            this is just the simplest. You can get O(N log N) expected time if you
            try, I think, and O(N) if you restrict inputs to simple polygons.
            Returns null if number of vertices passed is less than 3.
            Results should be passed through convex decomposition afterwards
            to ensure that each shape has few enough points to be used in Box2d.
            
            Warning: May be buggy with colinear points on hull.
            </summary>
            <param name="vertices">The vertices.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Collision.DistanceProxy">
            <summary>
            A distance proxy is used by the GJK algorithm.
            It encapsulates any shape.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DistanceProxy.Set(FarseerPhysics.Collision.Shapes.Shape,System.Int32)">
            <summary>
            Initialize the proxy using the given shape. The shape
            must remain in scope while the proxy is in use.
            </summary>
            <param name="shape">The shape.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DistanceProxy.GetSupport(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the supporting vertex index in the given direction.
            </summary>
            <param name="direction">The direction.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DistanceProxy.GetSupportVertex(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the supporting vertex in the given direction.
            </summary>
            <param name="direction">The direction.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DistanceProxy.GetVertex(System.Int32)">
            <summary>
            Get a vertex by index. Used by b2Distance.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Collision.SimplexCache">
            <summary>
            Used to warm start ComputeDistance.
            Set count to zero on first call.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexCache.Count">
            <summary>
            Length or area
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexCache.IndexA">
            <summary>
            Vertices on shape A
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexCache.IndexB">
            <summary>
            Vertices on shape B
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DistanceInput">
            <summary>
            Input for ComputeDistance.
            You have to option to use the shape radii
            in the computation. 
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DistanceOutput">
            <summary>
            Output for ComputeDistance.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DistanceOutput.Iterations">
            <summary>
            Number of GJK iterations used
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DistanceOutput.PointA">
            <summary>
            Closest point on shapeA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DistanceOutput.PointB">
            <summary>
            Closest point on shapeB
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.A">
            <summary>
            Barycentric coordinate for closest point 
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.IndexA">
            <summary>
            wA index
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.IndexB">
            <summary>
            wB index
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.W">
            <summary>
            wB - wA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.WA">
            <summary>
            Support point in proxyA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.WB">
            <summary>
            Support point in proxyB
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint">
            <summary>
            A revolute joint rains to bodies to share a common point while they
            are free to rotate about the point. The relative rotation about the shared
            point is the joint angle. You can limit the relative rotation with
            a joint limit that specifies a lower and upper angle. You can use a motor
            to drive the relative rotation about the shared point. A maximum motor torque
            is provided so that infinite forces are not generated.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.#ctor(FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Initialize the bodies, anchors, and reference angle using the world
            anchor.
            This requires defining an
            anchor point where the bodies are joined. The definition
            uses local anchor points so that the initial configuration
            can violate the constraint slightly. You also need to
            specify the initial relative angle for joint limits. This
            helps when saving and loading a game.
            The local anchor points are measured from the body's origin
            rather than the center of mass because:
            1. you might not know where the center of mass will be.
            2. if you add/remove shapes from a body and recompute the mass,
            the joints will be broken.
            </summary>
            <param name="body">The body.</param>
            <param name="bodyanchor">The body anchor.</param>
            <param name="worldanchor">The world anchor.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.JointAngle">
            <summary>
            Get the current joint angle in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.JointSpeed">
            <summary>
            Get the current joint angle speed in radians per second.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.LimitEnabled">
            <summary>
            Is the joint limit enabled?
            </summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.LowerLimit">
            <summary>
            Get the lower joint limit in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.UpperLimit">
            <summary>
            Get the upper joint limit in radians.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MotorEnabled">
            <summary>
            Is the joint motor enabled?
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MotorSpeed">
            <summary>
            Set the motor speed in radians per second.
            </summary>
            <value>The speed.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MaxMotorTorque">
            <summary>
            Set the maximum motor torque, usually in N-m.
            </summary>
            <value>The torque.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MotorTorque">
            <summary>
            Get the current motor torque, usually in N-m.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.DistanceJoint">
            <summary>
            A distance joint rains two points on two bodies
            to remain at a fixed distance from each other. You can view
            this as a massless, rigid rod.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.DistanceJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            This requires defining an
            anchor point on both bodies and the non-zero length of the
            distance joint. If you don't supply a length, the local anchor points
            is used so that the initial configuration can violate the constraint
            slightly. This helps when saving and loading a game.
            @warning Do not use a zero or short length.
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="anchorA">The first body anchor</param>
            <param name="anchorB">The second body anchor</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.DistanceJoint.Length">
            <summary>
            The natural length between the anchor points.
            Manipulating the length can lead to non-physical behavior when the frequency is zero.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.DistanceJoint.Frequency">
            <summary>
            The mass-spring-damper frequency in Hertz.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.DistanceJoint.DampingRatio">
            <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.DistanceJoint.LocalAnchorA">
            <summary>
            The local anchor point relative to bodyA's origin.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.DistanceJoint.LocalAnchorB">
            <summary>
            The local anchor point relative to bodyB's origin.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.TextureConverter.ClosePixels">
            <summary>
            TODO:
            1.) Das Array welches ich bekomme am besten in einen bool array verwandeln. Wrde die Geschwindigkeit verbessern
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.PolygonCreationAssistance">
            <summary>
            Class used as a data container and helper for the texture-to-vertices code.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.LineTools">
            <summary>
            Collection of helper methods for misc collisions.
            Does float tolerance and line collisions with lines and AABBs.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect2(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@)">
             <summary>
            Check if the lines a0->a1 and b0->b1 cross.
            If they do, intersectionPoint will be filled
            with the point of crossing.
            
            Grazing lines should not return true.
             
             </summary>
             <param name="a0"></param>
             <param name="a1"></param>
             <param name="b0"></param>
             <param name="b1"></param>
             <param name="intersectionPoint"></param>
             <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,System.Boolean,System.Boolean,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments (or lines) intersect,
            and, if so, the point of intersection. Use the <paramref name="firstIsSegment"/> and
            <paramref name="secondIsSegment"/> parameters to set whether the intersection point
            must be on the first and second line segments. Setting these
            both to true means you are doing a line-segment to line-segment
            intersection. Setting one of them to true means you are doing a
            line to line-segment intersection test, and so on.
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            Author: Jeremy Bell
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="point">This is set to the intersection
            point if an intersection is detected.</param>
            <param name="firstIsSegment">Set this to true to require that the 
            intersection point be on the first line segment.</param>
            <param name="secondIsSegment">Set this to true to require that the
            intersection point be on the second line segment.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments (or lines) intersect,
            and, if so, the point of intersection. Use the <paramref name="firstIsSegment"/> and
            <paramref name="secondIsSegment"/> parameters to set whether the intersection point
            must be on the first and second line segments. Setting these
            both to true means you are doing a line-segment to line-segment
            intersection. Setting one of them to true means you are doing a
            line to line-segment intersection test, and so on.
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            Author: Jeremy Bell
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <param name="firstIsSegment">Set this to true to require that the 
            intersection point be on the first line segment.</param>
            <param name="secondIsSegment">Set this to true to require that the
            intersection point be on the second line segment.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments intersect,
            and, if so, the point of intersection. 
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments intersect,
            and, if so, the point of intersection. 
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineSegmentVerticesIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,FarseerPhysics.Common.Vertices,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector2}@)">
            <summary>
            Get all intersections between a line segment and a list of vertices
            representing a polygon. The vertices reuse adjacent points, so for example
            edges one and two are between the first and second vertices and between the
            second and third vertices. The last edge is between vertex vertices.Count - 1
            and verts0. (ie, vertices from a Geometry or AABB)
            </summary>
            <param name="point1">The first point of the line segment to test</param>
            <param name="point2">The second point of the line segment to test.</param>
            <param name="vertices">The vertices, as described above</param>
            <param name="intersectionPoints">An list of intersection points. Any intersection points
            found will be added to this list.</param>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineSegmentAABBIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,FarseerPhysics.Collision.AABB,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector2}@)">
            <summary>
            Get all intersections between a line segment and an AABB. 
            </summary>
            <param name="point1">The first point of the line segment to test</param>
            <param name="point2">The second point of the line segment to test.</param>
            <param name="aabb">The AABB that is used for testing intersection.</param>
            <param name="intersectionPoints">An list of intersection points. Any intersection points found will be added to this list.</param>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.LoopShape">
            <summary>
            A loop Shape is a free form sequence of line segments that form a circular list.
            The loop may cross upon itself, but this is not recommended for smooth collision.
            The loop has double sided collision, so you can use inside and outside collision.
            Therefore, you may use any winding order.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.LoopShape.Count">
            <summary>
            The vertex count.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.LoopShape.Vertices">
            <summary>
            The vertices. These are not owned/freed by the loop Shape.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.GetChildEdge(FarseerPhysics.Collision.Shapes.EdgeShape@,System.Int32)">
            <summary>
            Get a child edge.
            </summary>
            <param name="edge">The edge.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.TestPoint(FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">a point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.ComputeMass(FarseerPhysics.Collision.Shapes.MassData@,System.Single)">
            <summary>
            Chains have zero mass.
            </summary>
            <param name="massData">Returns the mass data for this shape.</param>
            <param name="density">The density in kilograms per meter squared.</param>
        </member>
        <member name="M:FarseerPhysics.Factories.LinkFactory.CreateChain(FarseerPhysics.Dynamics.World,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Boolean,System.Boolean,System.Int32,System.Single)">
            <summary>
            Creates a chain.
            </summary>
            <param name="world">The world.</param>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="linkWidth">The width.</param>
            <param name="linkHeight">The height.</param>
            <param name="fixStart">if set to <c>true</c> [fix start].</param>
            <param name="fixEnd">if set to <c>true</c> [fix end].</param>
            <param name="numberOfLinks">The number of links.</param>
            <param name="linkDensity">The link density.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.JointEdge">
            <summary>
            A joint edge is used to connect bodies and joints together
            in a joint graph where each body is a node and each joint
            is an edge. A joint edge belongs to a doubly linked list
            maintained in each attached body. Each joint has two joint
            nodes, one for each attached body.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Joint">
            <summary>
            The joint.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Next">
            <summary>
            The next joint edge in the body's joint list.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Other">
            <summary>
            Provides quick access to the other body attached.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Prev">
            <summary>
            The previous joint edge in the body's joint list.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Island">
            <summary>
            This is an internal class.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Contacts.TOISolver.Solve(System.Single)">
            <summary>
            Perform one solver iteration. Returns true if converged.
            </summary>
            <param name="baumgarte">The baumgarte value.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateRectangle(System.Single,System.Single)">
            <summary>
            Build vertices to represent an axis-aligned box.
            </summary>
            <param name="hx">the half-width.</param>
            <param name="hy">the half-height.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateRectangle(System.Single,System.Single,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Build vertices to represent an oriented box.
            </summary>
            <param name="hx">the half-width.</param>
            <param name="hy">the half-height.</param>
            <param name="center">the center of the box in local coordinates.</param>
            <param name="angle">the rotation of the box in local coordinates.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateRoundedRectangle(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Creates a rounded rectangle with the specified width and height.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="xRadius">The rounding X radius.</param>
            <param name="yRadius">The rounding Y radius.</param>
            <param name="segments">The number of segments to subdivide the edges.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateEdge(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Set this as a single edge.
            </summary>
            <param name="start">The first point.</param>
            <param name="end">The second point.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateCircle(System.Single,System.Int32)">
            <summary>
            Creates a circle with the specified radius and number of edges.
            </summary>
            <param name="radius">The radius.</param>
            <param name="numberOfEdges">The number of edges. The more edges, the more it resembles a circle</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateEllipse(System.Single,System.Single,System.Int32)">
            <summary>
            Creates a ellipse with the specified width, height and number of edges.
            </summary>
            <param name="xRadius">Width of the ellipse.</param>
            <param name="yRadius">Height of the ellipse.</param>
            <param name="numberOfEdges">The number of edges. The more edges, the more it resembles an ellipse</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateCapsule(System.Single,System.Single,System.Int32)">
            <summary>
            Creates an capsule with the specified height, radius and number of edges.
            A capsule has the same form as a pill capsule.
            </summary>
            <param name="height">Height (inner height + 2 * radius) of the capsule.</param>
            <param name="endRadius">Radius of the capsule ends.</param>
            <param name="edges">The number of edges of the capsule ends. The more edges, the more it resembles an capsule</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateCapsule(System.Single,System.Single,System.Int32,System.Single,System.Int32)">
            <summary>
            Creates an capsule with the specified  height, radius and number of edges.
            A capsule has the same form as a pill capsule.
            </summary>
            <param name="height">Height (inner height + radii) of the capsule.</param>
            <param name="topRadius">Radius of the top.</param>
            <param name="topEdges">The number of edges of the top. The more edges, the more it resembles an capsule</param>
            <param name="bottomRadius">Radius of bottom.</param>
            <param name="bottomEdges">The number of edges of the bottom. The more edges, the more it resembles an capsule</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateGear(System.Single,System.Int32,System.Single,System.Single)">
            <summary>
            Creates a gear shape with the specified radius and number of teeth.
            </summary>
            <param name="radius">The radius.</param>
            <param name="numberOfTeeth">The number of teeth.</param>
            <param name="tipPercentage">The tip percentage.</param>
            <param name="toothHeight">Height of the tooth.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Collision.RayCastCallbackInternal">
            <summary>
            A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DynamicTreeNode">
            <summary>
            A node in the dynamic tree. The client does not interact with this directly.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DynamicTreeNode.AABB">
            <summary>
            This is the fattened AABB.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DynamicTree">
             <summary>
             A dynamic tree arranges data in a binary tree to accelerate
             queries such as volume queries and ray casts. Leafs are proxies
             with an AABB. In the tree we expand the proxy AABB by Settings.b2_fatAABBFactor
             so that the proxy AABB is bigger than the client object. This allows the client
             object to move by small amounts without triggering a tree update.
            
             Nodes are pooled and relocatable, so we use node indices rather than pointers.
             </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DynamicTree._path">
            <summary>
            This is used incrementally traverse the tree for re-balancing.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree.#ctor">
            <summary>
            constructing the tree initializes the node pool.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree.CreateProxy(FarseerPhysics.Collision.AABB@,System.Object)">
            <summary>
            Create a proxy. Provide a tight fitting AABB and a userData pointer.
            </summary>
            <param name="aabb">The aabb.</param>
            <param name="userData">The user data.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree.DestroyProxy(System.Int32)">
            <summary>
            Destroy a proxy. This asserts if the id is invalid.
            </summary>
            <param name="proxyId">The proxy id.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree.MoveProxy(System.Int32,FarseerPhysics.Collision.AABB@,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Move a proxy with a swepted AABB. If the proxy has moved outside of its fattened AABB,
            then the proxy is removed from the tree and re-inserted. Otherwise
            the function returns immediately.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="aabb">The aabb.</param>
            <param name="displacement">The displacement.</param>
            <returns>true if the proxy was re-inserted.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree.Rebalance(System.Int32)">
            <summary>
            Perform some iterations to re-balance the tree.
            </summary>
            <param name="iterations">The iterations.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree.GetUserData``1(System.Int32)">
            <summary>
            Get proxy user data.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proxyId">The proxy id.</param>
            <returns>the proxy user data or 0 if the id is invalid.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree.GetFatAABB(System.Int32,FarseerPhysics.Collision.AABB@)">
            <summary>
            Get the fat AABB for a proxy.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="fatAABB">The fat AABB.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree.ComputeHeight">
            <summary>
            Compute the height of the binary tree in O(N) time. Should not be
            called often.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree.Query(System.Func{System.Int32,System.Boolean},FarseerPhysics.Collision.AABB@)">
            <summary>
            Query an AABB for overlapping proxies. The callback class
            is called for each proxy that overlaps the supplied AABB.
            </summary>
            <param name="callback">The callback.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree.RayCast(FarseerPhysics.Collision.RayCastCallbackInternal,FarseerPhysics.Collision.RayCastInput@)">
            <summary>
            Ray-cast against the proxies in the tree. This relies on the callback
            to perform a exact ray-cast in the case were the proxy contains a Shape.
            The callback also performs the any collision filtering. This has performance
            roughly equal to k * log(n), where k is the number of collisions and n is the
            number of proxies in the tree.
            </summary>
            <param name="callback">a callback class that is called for each proxy that is hit by the ray.</param>
            <param name="input">the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).</param>
        </member>
        <member name="T:FarseerPhysics.Dynamics.TimeStep">
            <summary>
            This is an internal structure.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.TimeStep.dt">
            <summary>
            Time step (Delta time)
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.TimeStep.dtRatio">
            <summary>
            dt * inv_dt0
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.TimeStep.inv_dt">
            <summary>
            Inverse time step (0 if dt == 0).
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.BroadPhase">
            <summary>
            The broad-phase is used for computing pairs and performing volume queries and ray casts.
            This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
            It is up to the client to consume the new pairs and to track subsequent overlap.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.BroadPhase.CreateProxy(FarseerPhysics.Collision.AABB@,System.Object)">
            <summary>
            Create a proxy with an initial AABB. Pairs are not reported until
            UpdatePairs is called.
            </summary>
            <param name="aabb">The aabb.</param>
            <param name="userData">The user data.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.BroadPhase.DestroyProxy(System.Int32)">
            <summary>
            Destroy a proxy. It is up to the client to remove any pairs.
            </summary>
            <param name="proxyId">The proxy id.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.BroadPhase.GetFatAABB(System.Int32,FarseerPhysics.Collision.AABB@)">
            <summary>
            Get the AABB for a proxy.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.BroadPhase.GetUserData``1(System.Int32)">
            <summary>
            Get user data from a proxy. Returns null if the id is invalid.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proxyId">The proxy id.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.BroadPhase.TestOverlap(System.Int32,System.Int32)">
            <summary>
            Test overlap of fat AABBs.
            </summary>
            <param name="proxyIdA">The proxy id A.</param>
            <param name="proxyIdB">The proxy id B.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.BroadPhase.UpdatePairs``1(FarseerPhysics.Dynamics.BroadphaseDelegate)">
            <summary>
            Update the pairs. This results in pair callbacks. This can only add pairs.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="callback">The callback.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.BroadPhase.Query(System.Func{System.Int32,System.Boolean},FarseerPhysics.Collision.AABB@)">
            <summary>
            Query an AABB for overlapping proxies. The callback class
            is called for each proxy that overlaps the supplied AABB.
            </summary>
            <param name="callback">The callback.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.BroadPhase.ComputeHeight">
            <summary>
            Compute the height of the embedded tree.
            </summary>
            <returns></returns>
        </member>
        <member name="P:FarseerPhysics.Collision.BroadPhase.ProxyCount">
            <summary>
            Get the number of proxies.
            </summary>
            <value>The proxy count.</value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint">
            <summary>
            A prismatic joint. This joint provides one degree of freedom: translation
            along an axis fixed in body1. Relative rotation is prevented. You can
            use a joint limit to restrict the range of motion and a joint motor to
            drive the motion or to model joint friction.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.#ctor(FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            This requires defining a line of
            motion using an axis and an anchor point. The definition uses local
            anchor points and a local axis so that the initial configuration
            can violate the constraint slightly. The joint translation is zero
            when the local anchor points coincide in world space. Using local
            anchors and a local axis helps when saving and loading a game.
            </summary>
            <param name="body">The body.</param>
            <param name="anchor">The anchor.</param>
            <param name="axis">The axis.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.JointTranslation">
            <summary>
            Get the current joint translation, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.JointSpeed">
            <summary>
            Get the current joint translation speed, usually in meters per second.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.LimitEnabled">
            <summary>
            Is the joint limit enabled?
            </summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.LowerLimit">
            <summary>
            Get the lower joint limit, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.UpperLimit">
            <summary>
            Get the upper joint limit, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MotorEnabled">
            <summary>
            Is the joint motor enabled?
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MotorSpeed">
            <summary>
            Set the motor speed, usually in meters per second.
            </summary>
            <value>The speed.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MaxMotorForce">
            <summary>
            Set the maximum motor force, usually in N.
            </summary>
            <value>The force.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MotorForce">
            <summary>
            Get the current motor force, usually in N.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.BreakableBody">
            <summary>
            A type of body that supports multiple fixtures that can break apart.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.PreviousIndex(System.Int32)">
            <summary>
            Gets the previous index.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetSignedArea">
            <summary>
            Gets the signed area.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetArea">
            <summary>
            Gets the area.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetCentroid">
            <summary>
            Gets the centroid.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetRadius">
            <summary>
            Gets the radius based on area.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetCollisionBox">
            <summary>
            Returns an AABB for vertex.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Translate(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Translates the vertices with the specified vector.
            </summary>
            <param name="vector">The vector.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Scale(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Scales the vertices with the specified vector.
            </summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Rotate(System.Single)">
            <summary>
            Rotate the vertices with the defined value in radians.
            </summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.IsConvex">
            <summary>
            Assuming the polygon is simple; determines whether the polygon is convex.
            </summary>
            <returns>
            	<c>true</c> if it is convex; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.ForceCounterClockWise">
            <summary>
            Forces counter clock wise order.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.IsSimple">
            <summary>
            Check for edge crossings
            </summary>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.CheckPolygon">
             <summary>
             Checks if polygon is valid for use in Box2d engine.
             Last ditch effort to ensure no invalid polygons are
             added to world geometry.
            
             Performs a full check, for simplicity, convexity,
             orientation, minimum angle, and volume.  This won't
             be very efficient, and a lot of it is redundant when
             other tools in this section are used.
             </summary>
             <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.TraceEdge(FarseerPhysics.Common.Vertices)">
            <summary>
            Trace the edge of a non-simple polygon and return a simple polygon.
            
            Method:
            Start at vertex with minimum y (pick maximum x one if there are two).
            We aim our "lastDir" vector at (1.0, 0)
            We look at the two rays going off from our start vertex, and follow whichever
            has the smallest angle (in -Pi . Pi) wrt lastDir ("rightest" turn)
            Loop until we hit starting vertex:
            We add our current vertex to the list.
            We check the seg from current vertex to next vertex for intersections
            - if no intersections, follow to next vertex and continue
            - if intersections, pick one with minimum distance
            - if more than one, pick one with "rightest" next point (two possibilities for each)
            </summary>
            <param name="verts">The vertices.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.ProjectToAxis(Microsoft.Xna.Framework.Vector2@,System.Single@,System.Single@)">
            <summary>
            Projects to axis.
            </summary>
            <param name="axis">The axis.</param>
            <param name="min">The min.</param>
            <param name="max">The max.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.PointInPolygon(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Winding number test for a point in a polygon.
            </summary>
            See more info about the algorithm here: http://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm
            <param name="point">The point to be tested.</param>
            <returns>False if the winding number is even and the point is outside
            the polygon and True otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.PointInPolygonAngle(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Compute the sum of the angles made between the test point and each pair of points making up the polygon. 
            If this sum is 2pi then the point is an interior point, if 0 then the point is an exterior point. 
            ref: http://ozviz.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/  - Solution 2 
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.MaxManifoldPoints">
            <summary>
            The maximum number of contact points between two convex shapes.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.MaxPolygonVertices">
            <summary>
            The maximum number of vertices on a convex polygon.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.AABBExtension">
            <summary>
            This is used to fatten AABBs in the dynamic tree. This allows proxies
            to move by a small amount without triggering a tree adjustment.
            This is in meters.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.AABBMultiplier">
            <summary>
            This is used to fatten AABBs in the dynamic tree. This is used to predict
            the future position based on the current displacement.
            This is a dimensionless multiplier.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.LinearSlop">
            <summary>
            A small length used as a collision and constraint tolerance. Usually it is
            chosen to be numerically significant, but visually insignificant.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.AngularSlop">
            <summary>
            A small angle used as a collision and constraint tolerance. Usually it is
            chosen to be numerically significant, but visually insignificant.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.PolygonRadius">
            <summary>
            The radius of the polygon/edge shape skin. This should not be modified. Making
            this smaller means polygons will have an insufficient buffer for continuous collision.
            Making it larger may create artifacts for vertex collision.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.MaxTOIContacts">
            <summary>
            Maximum number of contacts to be handled to solve a TOI impact.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.VelocityThreshold">
            <summary>
            A velocity threshold for elastic collisions. Any collision with a relative linear
            velocity below this threshold will be treated as inelastic.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.MaxLinearCorrection">
            <summary>
            The maximum linear position correction used when solving constraints. This helps to
            prevent overshoot.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.MaxAngularCorrection">
            <summary>
            The maximum angular position correction used when solving constraints. This helps to
            prevent overshoot.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.ContactBaumgarte">
            <summary>
            This scale factor controls how fast overlap is resolved. Ideally this would be 1 so
            that overlap is removed in one time step. However using values close to 1 often lead
            to overshoot.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.TimeToSleep">
            <summary>
            The time that a body must be still before it will go to sleep.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.LinearSleepTolerance">
            <summary>
            A body cannot sleep if its linear velocity is above this tolerance.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.AngularSleepTolerance">
            <summary>
            A body cannot sleep if its angular velocity is above this tolerance.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.MaxTranslation">
            <summary>
            The maximum linear velocity of a body. This limit is very large and is used
            to prevent numerical problems. You shouldn't need to adjust this.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.MaxRotation">
            <summary>
            The maximum angular velocity of a body. This limit is very large and is used
            to prevent numerical problems. You shouldn't need to adjust this.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.EnableDiagnostics">
            <summary>
            Enabling diagnistics causes the engine to gather timing information.
            You can see how much time it took to solve the contacts, solve CCD and
            even how long it took to update the controllers.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.VelocityIterations">
            <summary>
            The number of velocity iterations used in the solver.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.PositionIterations">
            <summary>
            The number of position iterations used in the solver.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.ContinuousPhysics">
            <summary>
            Enable/Disable CCD
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.EnableWarmstarting">
            <summary>
            Enable/Disable warmstarting
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Settings.AllowSleep">
            <summary>
            Enable/Disable sleeping
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Settings.MixFriction(System.Single,System.Single)">
            <summary>
            Friction mixing law. Feel free to customize this.
            </summary>
            <param name="friction1">The friction1.</param>
            <param name="friction2">The friction2.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Settings.MixRestitution(System.Single,System.Single)">
            <summary>
            Restitution mixing law. Feel free to customize this.
            </summary>
            <param name="restitution1">The restitution1.</param>
            <param name="restitution2">The restitution2.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Factories.PathManager">
            <summary>
            An easy to use manager for creating paths.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.ConvertPathToEdges(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Int32)">
            <summary>
            Convert a path into a set of edges and attaches them to the specified body.
            Note: use only for static edges.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.ConvertPathToPolygon(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Single,System.Int32)">
            <summary>
            Convert a closed path into a polygon.
            Convex decomposition is automatically performed.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="density">The density.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.EvenlyDistibuteShapesAlongPath(FarseerPhysics.Dynamics.World,FarseerPhysics.Common.Path,System.Collections.Generic.IEnumerable{FarseerPhysics.Collision.Shapes.Shape},FarseerPhysics.Dynamics.BodyType,System.Int32,System.Single)">
            <summary>
            Duplicates the given Body along the given path for approximatly the given copies.
            </summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shapes">The shapes.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.EvenlyDistibuteShapesAlongPath(FarseerPhysics.Dynamics.World,FarseerPhysics.Common.Path,FarseerPhysics.Collision.Shapes.Shape,FarseerPhysics.Dynamics.BodyType,System.Int32,System.Single)">
            <summary>
            Duplicates the given Body along the given path for approximatly the given copies.
            </summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shape">The shape.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <param name="density">The density.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.MoveBodyOnPath(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Single,System.Single,System.Single)">
            <summary>
            Moves the body on the path.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="time">The time.</param>
            <param name="strength">The strength.</param>
            <param name="timeStep">The time step.</param>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.AttachBodiesWithRevoluteJoint(FarseerPhysics.Dynamics.World,System.Collections.Generic.List{FarseerPhysics.Dynamics.Body},Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean)">
            <summary>
            Attaches the bodies with revolute joints.
            </summary>
            <param name="world">The world.</param>
            <param name="bodies">The bodies.</param>
            <param name="localAnchorA">The local anchor A.</param>
            <param name="localAnchorB">The local anchor B.</param>
            <param name="connectFirstAndLast">if set to <c>true</c> [connect first and last].</param>
            <param name="collideConnected">if set to <c>true</c> [collide connected].</param>
        </member>
        <member name="M:FarseerPhysics.Factories.PathManager.AttachBodiesWithSliderJoint(FarseerPhysics.Dynamics.World,System.Collections.Generic.List{FarseerPhysics.Dynamics.Body},Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean,System.Single,System.Single)">
            <summary>
            Attaches the bodies with revolute joints.
            </summary>
            <param name="world">The world.</param>
            <param name="bodies">The bodies.</param>
            <param name="localAnchorA">The local anchor A.</param>
            <param name="localAnchorB">The local anchor B.</param>
            <param name="connectFirstAndLast">if set to <c>true</c> [connect first and last].</param>
            <param name="collideConnected">if set to <c>true</c> [collide connected].</param>
        </member>
        <member name="T:FarseerPhysics.Factories.FixtureFactory">
            <summary>
            An easy to use factory for creating bodies
            </summary>
        </member>
        <member name="M:FarseerPhysics.Factories.FixtureFactory.CreateCapsule(FarseerPhysics.Dynamics.World,System.Single,System.Single,System.Int32,System.Single,System.Int32,System.Single,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a capsule.
            Note: Automatically decomposes the capsule if it contains too many vertices (controlled by Settings.MaxPolygonVertices)
            </summary>
            <param name="world">The world.</param>
            <param name="height">The height.</param>
            <param name="topRadius">The top radius.</param>
            <param name="topEdges">The top edges.</param>
            <param name="bottomRadius">The bottom radius.</param>
            <param name="bottomEdges">The bottom edges.</param>
            <param name="density">The density.</param>
            <param name="position">The position.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.FixtureFactory.CreateRoundedRectangle(FarseerPhysics.Dynamics.World,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a rounded rectangle.
            Note: Automatically decomposes the capsule if it contains too many vertices (controlled by Settings.MaxPolygonVertices)
            </summary>
            <param name="world">The world.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="xRadius">The x radius.</param>
            <param name="yRadius">The y radius.</param>
            <param name="segments">The segments.</param>
            <param name="density">The density.</param>
            <param name="position">The position.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Factories.FixtureFactory.CreateBreakableBody(FarseerPhysics.Dynamics.World,FarseerPhysics.Common.Vertices,System.Single,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a breakable body. You would want to remove collinear points before using this.
            </summary>
            <param name="world">The world.</param>
            <param name="vertices">The vertices.</param>
            <param name="density">The density.</param>
            <param name="position">The position.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Factories.BodyFactory">
            <summary>
            An easy to use factory for creating bodies
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.WorldFlags.NewFixture">
            <summary>
            Flag that indicates a new fixture has been added to the world.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.WorldFlags.Locked">
            <summary>
            Flag that determines if the world is locked.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.WorldFlags.ClearForces">
            <summary>
            Flag that clear the forces after each time step.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.World">
            <summary>
            The world class manages all physics entities, dynamic simulation,
            and asynchronous queries.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.BodyAdded">
            <summary>
            Fires whenever a body has been added
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.BodyRemoved">
            <summary>
            Fires whenever a body has been removed
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.FixtureAdded">
            <summary>
            Fires whenever a fixture has been added
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.FixtureRemoved">
            <summary>
            Fires whenever a fixture has been removed
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.JointAdded">
            <summary>
            Fires whenever a joint has been added
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.World.JointRemoved">
            <summary>
            Fires whenever a joint has been removed
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.#ctor(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Dynamics.World"/> class.
            </summary>
            <param name="gravity">The gravity.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.CreateBody">
            <summary>
            Create a rigid body.
            Warning: This function is locked during callbacks.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.RemoveBody(FarseerPhysics.Dynamics.Body)">
            <summary>
            Destroy a rigid body.
            Warning: This function is locked during callbacks.
            Warning: This automatically deletes all associated shapes and joints.
            </summary>
            <param name="body">The body.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.AddJoint(FarseerPhysics.Dynamics.Joints.Joint)">
            <summary>
            Create a joint to constrain bodies together. This may cause the connected bodies to cease colliding.
            Warning: This function is locked during callbacks.
            </summary>
            <param name="joint">The joint.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.RemoveJoint(FarseerPhysics.Dynamics.Joints.Joint)">
            <summary>
            Destroy a joint. This may cause the connected bodies to begin colliding.
            Warning: This function is locked during callbacks.
            </summary>
            <param name="joint">The joint.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.Step(System.Single)">
            <summary>
            Take a time step. This performs collision detection, integration,
            and consraint solution.
            </summary>
            <param name="dt">The amount of time to simulate, this should not vary.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.ClearForces">
            <summary>
            Call this after you are done with time steps to clear the forces. You normally
            call this after each call to Step, unless you are performing sub-steps. By default,
            forces will be automatically cleared, so you don't need to call this function.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.QueryAABB(System.Func{FarseerPhysics.Dynamics.FixtureProxy,System.Boolean},FarseerPhysics.Collision.AABB@)">
            <summary>
            Query the world for all fixtures that potentially overlap the
            provided AABB.
            </summary>
            <param name="callback">A user implemented callback class.</param>
            <param name="aabb">The aabb query box.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.World.RayCast(FarseerPhysics.Dynamics.RayCastCallback,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Ray-cast the world for all fixtures in the path of the ray. Your callback
            controls whether you get the closest point, any point, or n-points.
            The ray-cast ignores shapes that contain the starting point.
            </summary>
            <param name="callback">A user implemented callback class.</param>
            <param name="point1">The ray starting point.</param>
            <param name="point2">The ray ending point.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FarseerPhysics.Dynamics.World.SolveTOI(FarseerPhysics.Dynamics.Body)" -->
        <!-- Badly formed XML comment ignored for member "M:FarseerPhysics.Dynamics.World.SolveTOI" -->
        <member name="P:FarseerPhysics.Dynamics.World.ProxyCount">
            <summary>
            Get the number of broad-phase proxies.
            </summary>
            <value>The proxy count.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.ContactCount">
            <summary>
            Get the number of contacts (each may have 0 or more contact points).
            </summary>
            <value>The contact count.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.Gravity">
            <summary>
            Change the global gravity vector.
            </summary>
            <value>The gravity.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.IsLocked">
            <summary>
            Is the world locked (in the middle of a time step).
            </summary>
            <value><c>true</c> if this instance is locked; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.AutoClearForces">
            <summary>
            Set flag to control automatic clearing of forces after each time step.
            </summary>
            <value><c>true</c> if it should auto clear forces; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.ContactManager">
            <summary>
            Get the contact manager for testing.
            </summary>
            <value>The contact manager.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.BodyList">
            <summary>
            Get the world body list. With the returned body, use Body.Next to get
            the next body in the world list. A null body indicates the end of the list.
            </summary>
            <value>Thehead of the world body list.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.World.ContactList">
            <summary>
            Get the world contact list. With the returned contact, use Contact.GetNext to get
            the next contact in the world list. A null contact indicates the end of the list.
            </summary>
            <value>The head of the world contact list.</value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.WeldJoint">
            <summary>
            A weld joint essentially glues two bodies together. A weld joint may
            distort somewhat because the island constraint solver is approximate.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.WeldJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            You need to specify a local anchor point
            where they are attached and the relative body angle. The position
            of the anchor point is important for computing the reaction torque.
            You can change the anchor points relative to bodyA or bodyB by changing LocalAnchorA
            and/or LocalAnchorB.
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second body anchor.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.WeldJoint.ReferenceAngle">
            <summary>
            The body2 angle minus body1 angle in the reference state (radians).
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.LineJoint">
            <summary>
            A line joint. This joint provides two degrees of freedom: translation
            along an axis fixed in body1 and rotation in the plane. You can use a
            joint limit to restrict the range of motion and a joint motor to drive
            the motion or to model joint friction.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.LineJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Initialize the bodies, anchors, axis, and reference angle using the local
            anchor and world axis.
            This requires defining a line of
            motion using an axis and an anchor point. Uses local
            anchor points and a local axis so that the initial configuration
            can violate the constraint slightly. The joint translation is zero
            when the local anchor points coincide in world space. Using local
            anchors and a local axis helps when saving and loading a game.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second body anchor.</param>
            <param name="axis">The axis.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.LineJoint.EnableLimit">
            <summary>
            Enable/disable the joint limit.
            </summary>
            <value><c>true</c> if [enable limit]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.LineJoint.LowerLimit">
            <summary>
            The lower translation limit, usually in meters.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.LineJoint.UpperLimit">
            <summary>
            The upper translation limit, usually in meters.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.LineJoint.MotorEnabled">
            <summary>
            Enable/disable the joint motor.
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.LineJoint.MotorSpeed">
            <summary>
            The desired motor speed in radians per second.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.LineJoint.MaxMotorForce">
            <summary>
            The maximum motor torque, usually in N-m.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.LineJoint.MotorForce">
            <summary>
            Get the current motor force, usually in N.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.LineJoint.LocalAnchorA">
            <summary>
            The local anchor point relative to body1's origin.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.LineJoint.LocalAnchorB">
            <summary>
            The local anchor point relative to body2's origin.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.LineJoint.JointTranslation">
            <summary>
            Get the current joint translation, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.LineJoint.JointSpeed">
            <summary>
            Get the current joint translation speed, usually in meters per second.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Dynamics.FixtureProxy">
            <summary>
            This proxy is used internally to connect fixtures to the broad-phase.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Fixture">
            <summary>
            A fixture is used to attach a Shape to a body for collision detection. A fixture
            inherits its transform from its parent. Fixtures hold additional non-geometric data
            such as friction, collision filters, etc.
            Fixtures are created via Body.CreateFixture.
            Warning: You cannot reuse fixtures.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Fixture.OnCollision">
            <summary>
            Fires when two shapes collide and a contact is created between them.
            Note that the first fixture argument is always the fixture that the delegate is subscribed to.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.Fixture.OnSeparation">
            <summary>
            Fires when two shapes separate and a contact is removed between them.
            Note that the first fixture argument is always the fixture that the delegate is subscribed to.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.TestPoint(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Test a point for containment in this fixture.
            </summary>
            <param name="point">A point in world coordinates.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,System.Int32)">
            <summary>
            Cast a ray against this Shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="childIndex">Index of the child.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.GetMassData(FarseerPhysics.Collision.Shapes.MassData@)">
            <summary>
            Get the mass data for this fixture. The mass data is based on the density and
            the Shape. The rotational inertia is about the Shape's origin.
            </summary>
            <param name="massData">The mass data.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.GetAABB(FarseerPhysics.Collision.AABB@,System.Int32)">
            <summary>
            Get the fixture's AABB. This AABB may be enlarge and/or stale.
            If you need a more accurate AABB, compute it using the Shape and
            the body transform.
            </summary>
            <param name="aabb">The aabb.</param>
            <param name="childIndex">Index of the child.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.RestoreCollisionWith(FarseerPhysics.Dynamics.Fixture)">
            <summary>
            Restores collisions between this fixture and the provided fixture.
            </summary>
            <param name="fixture">The fixture.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.IgnoreCollisionWith(FarseerPhysics.Dynamics.Fixture)">
            <summary>
            Ignores collisions between this fixture and the provided fixture.
            </summary>
            <param name="fixture">The fixture.</param>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Fixture.IsFixtureIgnored(FarseerPhysics.Dynamics.Fixture)">
            <summary>
            Determines whether collisions are ignored between this fixture and the provided fixture.
            </summary>
            <param name="fixture">The fixture.</param>
            <returns>
            	<c>true</c> if the fixture is ignored; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.ShapeType">
            <summary>
            Get the type of the child Shape. You can use this to down cast to the concrete Shape.
            </summary>
            <value>The type of the shape.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.Shape">
            <summary>
            Get the child Shape. You can modify the child Shape, however you should not change the
            number of vertices because this will crash some collision caching mechanisms.
            </summary>
            <value>The shape.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.IsSensor">
            <summary>
            Gets or sets a value indicating whether this fixture is a sensor.
            </summary>
            <value><c>true</c> if this instance is a sensor; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.Body">
            <summary>
            Get the parent body of this fixture. This is null if the fixture is not attached.
            </summary>
            <value>The body.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.UserData">
            <summary>
            Set the user data. Use this to store your application specific data.
            </summary>
            <value>The user data.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.Density">
            <summary>
            Gets or sets the density.
            </summary>
            <value>The density.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.Friction">
            <summary>
            Get or set the coefficient of friction.
            </summary>
            <value>The friction.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.Restitution">
            <summary>
            Get or set the coefficient of restitution.
            </summary>
            <value>The restitution.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.CollisionGroup">
            <summary>
            Collision groups allow a certain group of objects to never collide (negative)
            or always collide (positive). Zero means no collision group. Non-zero group
            filtering always wins against the mask bits.
            Warning: The filter will not take effect until next step.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.CollidesWith">
            <summary>
            The collision mask bits. This states the categories that this
            shape would accept for collision.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Fixture.CollisionCategories">
            <summary>
            The collision category bits. Normally you would just set one bit.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.TestPoint(FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">a point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.ComputeMass(FarseerPhysics.Collision.Shapes.MassData@,System.Single)">
            <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
            <param name="massData">Returns the mass data for this shape.</param>
            <param name="density">The density in kilograms per meter squared.</param>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.Shape">
            <summary>
            Draw shapes.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.Joint">
            <summary>
            Draw joint connections.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.AABB">
            <summary>
            Draw axis aligned bounding boxes.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.Pair">
            <summary>
            Draw broad-phase pairs.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.CenterOfMass">
            <summary>
            Draw center of mass frame.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.DebugPanel">
            <summary>
            Draw useful debug data such as timings and number of bodies, joints, contacts and more.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.ContactPoints">
            <summary>
            Draw contact points between colliding bodies.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.ContactNormals">
            <summary>
            Draw contact normals. Need ContactPoints to be enabled first.
            </summary>
        </member>
        <member name="F:FarseerPhysics.DebugViewFlags.PolygonPoints">
            <summary>
            Draws the vertices of polygons
            </summary>
        </member>
        <member name="T:FarseerPhysics.DebugView">
            Implement and register this class with a World to provide debug drawing of physics
            entities in your game.
        </member>
        <member name="M:FarseerPhysics.DebugView.AppendFlags(FarseerPhysics.DebugViewFlags)">
            <summary>
            Append flags to the current flags.
            </summary>
            <param name="flags">The flags.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.RemoveFlags(FarseerPhysics.DebugViewFlags)">
            <summary>
            Remove flags from the current flags.
            </summary>
            <param name="flags">The flags.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawPolygon(Microsoft.Xna.Framework.Vector2[],System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Draw a closed polygon provided in CCW order.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="count">The vertex count.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawSolidPolygon(Microsoft.Xna.Framework.Vector2[],System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Draw a solid closed polygon provided in CCW order.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="count">The vertex count.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawCircle(Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draw a circle.
            </summary>
            <param name="center">The center.</param>
            <param name="radius">The radius.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawSolidCircle(Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single)">
            <summary>
            Draw a solid circle.
            </summary>
            <param name="center">The center.</param>
            <param name="radius">The radius.</param>
            <param name="axis">The axis.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawSegment(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single)">
            <summary>
            Draw a line segment.
            </summary>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.DrawTransform(FarseerPhysics.Common.Transform@)">
            <summary>
            Draw a transform. Choose your own length scale.
            </summary>
            <param name="transform">The transform.</param>
        </member>
        <member name="P:FarseerPhysics.DebugView.Flags">
            <summary>
            Gets or sets the debug view flags.
            </summary>
            <value>The flags.</value>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.PolygonShape">
            <summary>
            Represents a simple non-selfintersecting convex polygon.
            If you want to have concave polygons, you will have to use the <see cref="T:FarseerPhysics.Common.Decomposition.BayazitDecomposer"/> or the <see cref="T:FarseerPhysics.Common.Decomposition.EarclipDecomposer"/>
            to decompose the concave polygon into 2 or more convex polygons.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.Set(FarseerPhysics.Common.Vertices)">
            <summary>
            Copy vertices. This assumes the vertices define a convex polygon.
            It is assumed that the exterior is the the right of each edge.
            </summary>
            <param name="vertices">The vertices.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.SetAsBox(System.Single,System.Single)">
            <summary>
            Build vertices to represent an axis-aligned box.
            </summary>
            <param name="halfWidth">The half-width.</param>
            <param name="halfHeight">The half-height.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.SetAsBox(System.Single,System.Single,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Build vertices to represent an oriented box.
            </summary>
            <param name="halfWidth">The half-width..</param>
            <param name="halfHeight">The half-height.</param>
            <param name="center">The center of the box in local coordinates.</param>
            <param name="angle">The rotation of the box in local coordinates.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.SetAsEdge(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Set this as a single edge.
            </summary>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.TestPoint(FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">a point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.ComputeMass(FarseerPhysics.Collision.Shapes.MassData@,System.Single)">
            <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
            <param name="massData">Returns the mass data for this shape.</param>
            <param name="density">The density in kilograms per meter squared.</param>
        </member>
        <member name="T:FarseerPhysics.Dynamics.RayCastCallback">
            <summary>
            Called for each fixture found in the query. You control how the ray cast
            proceeds by returning a float:
            return -1: ignore this fixture and continue
            return 0: terminate the ray cast
            return fraction: clip the ray to this point
            return 1: don't clip the ray and continue
            @param fixture the fixture hit by the ray
            @param point the point of initial intersection
            @param normal the normal vector at the point of intersection
            @return -1 to filter, 0 to terminate, fraction to clip the ray for
            closest hit, 1 to continue
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.EndContactDelegate">
            <summary>
            This delegate is called when a contact is deleted
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.BeginContactDelegate">
            <summary>
            This delegate is called when a contact is created
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.IsValid(System.Single)">
            <summary>
            This function is used to ensure that a floating point number is
            not a NaN or infinity.
            </summary>
            <param name="x">The x.</param>
            <returns>
            	<c>true</c> if the specified x is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.InvSqrt(System.Single)">
            <summary>
            This is a approximate yet fast inverse square-root.
            </summary>
            <param name="x">The x.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.VectorAngle(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Return the angle between two vectors on a plane
            The angle is from vector 1 to vector 2, positive anticlockwise
            The result is between -pi -> pi
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Area(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Returns a positive number if c is to the left of the line going from a to b.
            </summary>
            <returns>Positive number if point is left, negative if point is right, 
            and 0 if points are collinear.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Area(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Returns a positive number if c is to the left of the line going from a to b.
            </summary>
            <returns>Positive number if point is left, negative if point is right, 
            and 0 if points are collinear.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Collinear(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Determines if three vertices are collinear (ie. on a straight line)
            </summary>
            <param name="a">First vertex</param>
            <param name="b">Second vertex</param>
            <param name="c">Third vertex</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.FloatEquals(System.Single,System.Single,System.Single)">
            <summary>
            Checks if a floating point Value is equal to another,
            within a certain tolerance.
            </summary>
            <param name="value1">The first floating point Value.</param>
            <param name="value2">The second floating point Value.</param>
            <param name="delta">The floating point tolerance.</param>
            <returns>True if the values are "equal", false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.FloatInRange(System.Single,System.Single,System.Single)">
            <summary>
            Checks if a floating point Value is within a specified
            range of values (inclusive).
            </summary>
            <param name="value">The Value to check.</param>
            <param name="min">The minimum Value.</param>
            <param name="max">The maximum Value.</param>
            <returns>True if the Value is within the range specified,
            false otherwise.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.Mat22">
            <summary>
            A 2-by-2 matrix. Stored in column-major order.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            construct this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            construct this matrix using scalars.
            </summary>
            <param name="a11">The a11.</param>
            <param name="a12">The a12.</param>
            <param name="a21">The a21.</param>
            <param name="a22">The a22.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.#ctor(System.Single)">
            <summary>
            construct this matrix using an angle. This matrix becomes
            an orthonormal rotation matrix.
            </summary>
            <param name="angle">The angle.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.Set(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Initialize this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.Set(System.Single)">
            <summary>
            Initialize this matrix using an angle. This matrix becomes
            an orthonormal rotation matrix.
            </summary>
            <param name="angle">The angle.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.SetIdentity">
            <summary>
            Set this to the identity matrix.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.SetZero">
            <summary>
            Set this matrix to all zeros.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.Solve(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="P:FarseerPhysics.Common.Mat22.Angle">
            <summary>
            Extract the angle from this matrix (assumed to be
            a rotation matrix).
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Common.Mat33">
            <summary>
            A 3-by-3 matrix. Stored in column-major order.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Construct this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
            <param name="c3">The c3.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.SetZero">
            <summary>
            Set this matrix to all zeros.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.Solve33(Microsoft.Xna.Framework.Vector3)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.Solve22(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases. Solve only the upper
            2-by-2 matrix equation.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Common.Transform">
            <summary>
            A transform contains translation and rotation. It is used to represent
            the position and orientation of rigid frames.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Transform.#ctor(Microsoft.Xna.Framework.Vector2,FarseerPhysics.Common.Mat22@)">
            <summary>
            Initialize using a position vector and a rotation matrix.
            </summary>
            <param name="position">The position.</param>
            <param name="r">The r.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Transform.SetIdentity">
            <summary>
            Set this to the identity transform.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Transform.Set(Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Set this based on the position and angle.
            </summary>
            <param name="position">The position.</param>
            <param name="angle">The angle.</param>
        </member>
        <member name="P:FarseerPhysics.Common.Transform.Angle">
            <summary>
            Calculate the angle that the rotation matrix represents.
            </summary>
            <value></value>
        </member>
        <member name="T:FarseerPhysics.Common.Sweep">
            <summary>
            This describes the motion of a body/shape for TOI computation.
            Shapes are defined with respect to the body origin, which may
            no coincide with the center of mass. However, to support dynamics
            we must interpolate the center of mass position.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Sweep.a">
            <summary>
            World angles
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Sweep.LocalCenter">
            <summary>
            Local center of mass position
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Sweep.GetTransform(FarseerPhysics.Common.Transform@,System.Single)">
            <summary>
            Get the interpolated transform at a specific time.
            </summary>
            <param name="xf">The xf.</param>
            <param name="alpha">alpha is a factor in [0,1], where 0 indicates t0..</param>
        </member>
        <member name="M:FarseerPhysics.Common.Sweep.Advance(System.Single)">
            <summary>
            Advance the sweep forward, yielding a new initial state.
            </summary>
            <param name="t">new initial time..</param>
        </member>
        <member name="M:FarseerPhysics.Common.Sweep.Normalize">
            <summary>
            Normalize the angles.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.ConvexHull.Melkman.GetConvexHull(FarseerPhysics.Common.Vertices)">
            <summary>
            Creates a convex hull of the Vertices.
            Note: Vertices must be of a simple polygon, i.e. edges do not overlap.
            </summary>
            <remarks>
            Implemented using Melkman's Convex Hull Algorithm - O(n) time complexity.
            Reference: http://www.ams.sunysb.edu/~jsbm/courses/345/melkman.pdf
            Requires that vertices are of a simple polygon. Handles collinear points.
            </remarks>
            <returns>A convex hull in counterclockwise winding order.</returns>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.MassData">
            <summary>
            This holds the mass data computed for a shape.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.MassData.Center">
            <summary>
            The position of the shape's centroid relative to the shape's origin.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.MassData.Inertia">
            <summary>
            The rotational inertia of the shape about the local origin.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.MassData.Mass">
            <summary>
            The mass of the shape, usually in kilograms.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Dynamics.Joints.SliderJoint">
            <summary>
            A distance joint contrains two points on two bodies
            to remain at a fixed distance from each other. You can view
            this as a massless, rigid rod.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Dynamics.Joints.SliderJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Dynamics.Joints.SliderJoint"/> class.
            Warning: Do not use a zero or short length.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second body anchor.</param>
            <param name="minLength">The minimum length between anchorpoints</param>
            <param name="maxlength">The maximum length between anchorpoints.</param>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.MaxLength">
            <summary>
            The maximum length between the anchor points.
            </summary>
            <value>The length.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.MinLength">
            <summary>
            The minimal length between the anchor points.
            </summary>
            <value>The length.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.Frequency">
            <summary>
            The mass-spring-damper frequency in Hertz.
            </summary>
            <value>The frequency.</value>
        </member>
        <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.DampingRatio">
            <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
            <value>The damping ratio.</value>
        </member>
        <member name="F:FarseerPhysics.Dynamics.ContactManager.BeginContact">
            <summary>
            Fires when a contact is created
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.ContactManager.EndContact">
            <summary>
            Fires when a contact is deleted
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.ContactManager.PostSolve">
            <summary>
            Fires after the solver has run
            </summary>
        </member>
        <member name="F:FarseerPhysics.Dynamics.ContactManager.PreSolve">
            <summary>
            Fires before the solver runs
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Execute(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.PolygonManipulation.PolyClipType,FarseerPhysics.Common.PolygonManipulation.PolyClipError@)">
            <summary>
            Implements "A new algorithm for Boolean operations on general polygons" 
            available here: http://liama.ia.ac.cn/wiki/_media/user:dong:dong_cg_05.pdf
            Merges two polygons, a subject and a clip with the specified operation. Polygons may not be 
            self-intersecting.
            
            Warning: May yield incorrect results or even crash if polygons contain colinear points.
            </summary>
            <param name="subject">The subject polygon.</param>
            <param name="clip">The clip polygon, which is added, 
            substracted or intersected with the subject</param>
            <param name="clipType">The operation to be performed. Either
            Union, Difference or Intersection.</param>
            <param name="error">The error generated (if any)</param>
            <returns>A list of closed polygons, which make up the result of the clipping operation.
            Outer contours are ordered counter clockwise, holes are ordered clockwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateIntersections(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@)">
            <summary>
            Calculates all intersections between two polygons.
            </summary>
            <param name="polygon1">The first polygon.</param>
            <param name="polygon2">The second polygon.</param>
            <param name="slicedPoly1">Returns the first polygon with added intersection points.</param>
            <param name="slicedPoly2">Returns the second polygon with added intersection points.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplicalChain(FarseerPhysics.Common.Vertices,System.Collections.Generic.List{System.Single}@,System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}@)">
            <summary>
            Calculates the simplical chain corresponding to the input polygon.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateEdgeCharacter(System.Collections.Generic.List{System.Single},System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{System.Single}@,System.Collections.Generic.List{System.Single}@)">
            <summary>
            Calculates the characteristics function for all edges of
            a given simplical chain.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateResultChain(System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{System.Single},FarseerPhysics.Common.PolygonManipulation.PolyClipType,System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}@)">
            <summary>
            Calculates the result between the subject and clip simplical chains,
            based on the provided operation.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.BuildPolygonsFromChain(System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{FarseerPhysics.Common.Vertices}@)">
            <summary>
            Calculates the polygon(s) from the result simplical chain.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateBeta(Microsoft.Xna.Framework.Vector2,FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge,System.Single)">
            <summary>
            Needed to calculate the characteristics function of a simplex.
            </summary>
            <remarks>Used by method <c>CalculateEdgeCharacter()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Needed for sorting multiple intersections points on the same edge.
            </summary>
            <remarks>Used by method <c>CalculateIntersections()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplexCoefficient(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Returns the coefficient of a simplex.
            </summary>
            <remarks>Used by method <c>CalculateSimplicalChain()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointInSimplex(Microsoft.Xna.Framework.Vector2,FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge)">
            <summary>
            Winding number test for a point in a simplex.
            </summary>
            <param name="point">The point to be tested.</param>
            <param name="edge">The edge that the point is tested against.</param>
            <returns>False if the winding number is even and the point is outside
            the simplex and True otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PoinOnLineSegment(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Tests if a point lies on a line segment.
            </summary>
            <remarks>Used by method <c>CalculateBeta()</c>.</remarks>
        </member>
        <member name="T:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge">
            <summary>Specifies an Edge. Edges are used to represent simplicies in simplical chains</summary>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.CuttingTools.SplitShape(FarseerPhysics.Dynamics.Fixture,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@)">
            <summary>
            Split a fixture into 2 vertice collections using the given entry and exit-point.
            </summary>
            <param name="fixture">The Fixture to split</param>
            <param name="entryPoint">The entry point - The start point</param>
            <param name="exitPoint">The exit point - The end point</param>
            <param name="splitSize">The size of the split. Think of this as the laser-width</param>
            <param name="first">The first collection of vertexes</param>
            <param name="second">The second collection of vertexes</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.CuttingTools.Cut(FarseerPhysics.Dynamics.World,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            This is a high-level function to cuts fixtures inside the given world, using the start and end points.
            </summary>
            <param name="world">The world.</param>
            <param name="start">The startpoint.</param>
            <param name="end">The endpoint.</param>
            <param name="thickness">The thickness of the cut</param>
        </member>
    </members>
</doc>
